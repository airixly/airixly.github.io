---
layout: post
title: Git命令
---

#### diff

* git diff:修改后还未add到staged的文件与staged中的文件的差异
* git diff --cached(staged):add到staged但没有commit的文件与上次commit后的文件的差异

#### rm

* git rm:移除已跟踪的文件,并连带从工作目录中删除
* git rm -f:若文件已经放到staged中,则必须使用 -f 强制删除
* git rm --cached:移除跟踪,但不删除原文件

#### undo

**修改最后一次提交**

* git commit --amend:如果前一次提交后没有任何改动,则重新编辑提交说明.如果忘了add某些修改,则可以补上add操作,然后 --amend 提交.因为修正会改变提交的SHA-1值,所以不要在推送完后再去修正

**取消暂存的文件**

* git reset HEAD <file>:取消暂存,让文件回到已修改未暂存的状态

**取消对文件的修改**

* git checkout -- <file>:撤销对文件的修改,会丢失所有的修改内容

**修改多个提交说明**

* git rebase -i HEAD~n:交互式修改最近的n次提交的说明.

在rebase脚本中有pick,edit,squash操作:

* rebase脚本中删除一行表示删除此提交
* edit表示编辑提交说明
* squash表示应用此变更与之前的变更进行合并
* 在edit过程中,可以使用git reset HEAD^撤销当前提交,进行拆分提交

**删除文件**

* git filter-branch --tree-filter 'rm -f password.txt' HEAD:从所有提交中删除password.txt文件.最好在测试分支上使用此命令,然后hard-reset主分支,在HEAD之后传递--all命令会在所有分支上运行filter-branch

**将子目录设置为新的根目录**

* git filter-branch --subdirectory-filter trunk HEAD:把trunk目录设置为新的项目根目录

#### branch

**衍合**

确保远程分支里的提交历史更清晰,仿佛所有修改都是先后进行的,尽管它们是同时发生的

* git rebase [主分支]:回到所在分支和要衍合进去的分支的共同祖先,提取每次提交产生的差异保存到临时文件,然后转换到要衍合入的分支,依序应用每个差异补丁文件
* git rebase [主分支,特性分支]:先检出特性分支,然后在主分支上重演

永远不要衍合那些已经推送到公共仓库的更新,否则会导致提交历史非常混乱

#### stash

* git stash:把修改过的被追踪文件和暂存的变更保存到一个未完结变更的堆栈中  
* git stash list:查看现有的储藏  
* git stash apply:应用最近的储藏    
* git stash apply stash@{1}:应用前一个储藏  
* git stash apply --index:重新应用被暂存的变更  
* git stash drop stash@{1}:移除前一个储藏  
* git stash branch:储藏后,继续在当前分支上修改了被储藏的文件后,尝试应用变更会碰到冲突.如果想更方便的方法来重新检验储藏的变更,可以创建新的分支,检出储藏工作时所处的提交,重新应用工作,如果成功会丢弃储藏  

#### debug

* git blame -L 12,22 README.md:显示文件中对每一行进行修改的最近一次提交,-L限制输出范围
* git bisect start:bisect会在提交历史中进行二分查找来尽快确定引入错误的提交

#### submodule

* git submodule add *.git:添加子模块
* git submodule init:克隆带子模块的项目后初始化配置文件,
* git submodule update:从原项目拉取所有数据并检出上层项目所列的合适提交.如果子模块有了更新,则拉取合并后必须再次运行git submodule update,让子模块的指针对应于子模块目录的真实状态

#### subtree

* git remote add test_remote *.git:添加远程项目当作项目中的一个远程引用
* git fetch test_remote:获取数据
* git checkout -b test_branch test_remote/master:检出自身分支
* git read-tree --prefix=test/ -u test_branch:拉取test分支到主项目的master分支的test子目录
* git merge --squash -s subtree --no-commit test_branch:将test_branch的更新应用到master分支
* git diff-tree -p test_branch:得到test目录和test_branch分支的区别